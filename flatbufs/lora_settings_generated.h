// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LORASETTINGS_GROUNDSTATION_H_
#define FLATBUFFERS_GENERATED_LORASETTINGS_GROUNDSTATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace groundstation {

struct LoRaConfig;
struct LoRaConfigBuilder;

struct LoRaSettings;
struct LoRaSettingsBuilder;

struct LoRaConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoRaConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQ = 4,
    VT_BANDWIDTH = 6,
    VT_SPREADING_FACTOR = 8,
    VT_CODING_RATE = 10,
    VT_PREAMBLE_LENGTH = 12,
    VT_SYNC_WORD = 14,
    VT_POWER = 16
  };
  float freq() const {
    return GetField<float>(VT_FREQ, 434.0f);
  }
  float bandwidth() const {
    return GetField<float>(VT_BANDWIDTH, 125.0f);
  }
  uint8_t spreading_factor() const {
    return GetField<uint8_t>(VT_SPREADING_FACTOR, 7);
  }
  uint8_t coding_rate() const {
    return GetField<uint8_t>(VT_CODING_RATE, 6);
  }
  uint8_t preamble_length() const {
    return GetField<uint8_t>(VT_PREAMBLE_LENGTH, 8);
  }
  uint8_t sync_word() const {
    return GetField<uint8_t>(VT_SYNC_WORD, 18);
  }
  float power() const {
    return GetField<float>(VT_POWER, 8.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FREQ, 4) &&
           VerifyField<float>(verifier, VT_BANDWIDTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_SPREADING_FACTOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_CODING_RATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREAMBLE_LENGTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_SYNC_WORD, 1) &&
           VerifyField<float>(verifier, VT_POWER, 4) &&
           verifier.EndTable();
  }
};

struct LoRaConfigBuilder {
  typedef LoRaConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_freq(float freq) {
    fbb_.AddElement<float>(LoRaConfig::VT_FREQ, freq, 434.0f);
  }
  void add_bandwidth(float bandwidth) {
    fbb_.AddElement<float>(LoRaConfig::VT_BANDWIDTH, bandwidth, 125.0f);
  }
  void add_spreading_factor(uint8_t spreading_factor) {
    fbb_.AddElement<uint8_t>(LoRaConfig::VT_SPREADING_FACTOR, spreading_factor, 7);
  }
  void add_coding_rate(uint8_t coding_rate) {
    fbb_.AddElement<uint8_t>(LoRaConfig::VT_CODING_RATE, coding_rate, 6);
  }
  void add_preamble_length(uint8_t preamble_length) {
    fbb_.AddElement<uint8_t>(LoRaConfig::VT_PREAMBLE_LENGTH, preamble_length, 8);
  }
  void add_sync_word(uint8_t sync_word) {
    fbb_.AddElement<uint8_t>(LoRaConfig::VT_SYNC_WORD, sync_word, 18);
  }
  void add_power(float power) {
    fbb_.AddElement<float>(LoRaConfig::VT_POWER, power, 8.0f);
  }
  explicit LoRaConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoRaConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoRaConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoRaConfig> CreateLoRaConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float freq = 434.0f,
    float bandwidth = 125.0f,
    uint8_t spreading_factor = 7,
    uint8_t coding_rate = 6,
    uint8_t preamble_length = 8,
    uint8_t sync_word = 18,
    float power = 8.0f) {
  LoRaConfigBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_bandwidth(bandwidth);
  builder_.add_freq(freq);
  builder_.add_sync_word(sync_word);
  builder_.add_preamble_length(preamble_length);
  builder_.add_coding_rate(coding_rate);
  builder_.add_spreading_factor(spreading_factor);
  return builder_.Finish();
}

struct LoRaSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoRaSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAT_NAME = 4,
    VT_CONFIG = 6,
    VT_TX_PERMITTED = 8,
    VT_TX_TRANSMISSION_DELAY = 10,
    VT_RX_PERMITTED = 12,
    VT_LAST_CHANGED_TIMESTAMP = 14,
    VT_ENABLE_LIVE_LOGS = 16
  };
  const ::flatbuffers::String *sat_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SAT_NAME);
  }
  const groundstation::LoRaConfig *config() const {
    return GetPointer<const groundstation::LoRaConfig *>(VT_CONFIG);
  }
  bool tx_permitted() const {
    return GetField<uint8_t>(VT_TX_PERMITTED, 1) != 0;
  }
  uint64_t tx_transmission_delay() const {
    return GetField<uint64_t>(VT_TX_TRANSMISSION_DELAY, 1000ULL);
  }
  bool rx_permitted() const {
    return GetField<uint8_t>(VT_RX_PERMITTED, 0) != 0;
  }
  uint64_t last_changed_timestamp() const {
    return GetField<uint64_t>(VT_LAST_CHANGED_TIMESTAMP, 0);
  }
  bool enable_live_logs() const {
    return GetField<uint8_t>(VT_ENABLE_LIVE_LOGS, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SAT_NAME) &&
           verifier.VerifyString(sat_name()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           VerifyField<uint8_t>(verifier, VT_TX_PERMITTED, 1) &&
           VerifyField<uint64_t>(verifier, VT_TX_TRANSMISSION_DELAY, 8) &&
           VerifyField<uint8_t>(verifier, VT_RX_PERMITTED, 1) &&
           VerifyField<uint64_t>(verifier, VT_LAST_CHANGED_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_LIVE_LOGS, 1) &&
           verifier.EndTable();
  }
};

struct LoRaSettingsBuilder {
  typedef LoRaSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sat_name(::flatbuffers::Offset<::flatbuffers::String> sat_name) {
    fbb_.AddOffset(LoRaSettings::VT_SAT_NAME, sat_name);
  }
  void add_config(::flatbuffers::Offset<groundstation::LoRaConfig> config) {
    fbb_.AddOffset(LoRaSettings::VT_CONFIG, config);
  }
  void add_tx_permitted(bool tx_permitted) {
    fbb_.AddElement<uint8_t>(LoRaSettings::VT_TX_PERMITTED, static_cast<uint8_t>(tx_permitted), 1);
  }
  void add_tx_transmission_delay(uint64_t tx_transmission_delay) {
    fbb_.AddElement<uint64_t>(LoRaSettings::VT_TX_TRANSMISSION_DELAY, tx_transmission_delay, 1000ULL);
  }
  void add_rx_permitted(bool rx_permitted) {
    fbb_.AddElement<uint8_t>(LoRaSettings::VT_RX_PERMITTED, static_cast<uint8_t>(rx_permitted), 0);
  }
  void add_last_changed_timestamp(uint64_t last_changed_timestamp) {
    fbb_.AddElement<uint64_t>(LoRaSettings::VT_LAST_CHANGED_TIMESTAMP, last_changed_timestamp, 0);
  }
  void add_enable_live_logs(bool enable_live_logs) {
    fbb_.AddElement<uint8_t>(LoRaSettings::VT_ENABLE_LIVE_LOGS, static_cast<uint8_t>(enable_live_logs), 1);
  }
  explicit LoRaSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoRaSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoRaSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoRaSettings> CreateLoRaSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sat_name = 0,
    ::flatbuffers::Offset<groundstation::LoRaConfig> config = 0,
    bool tx_permitted = true,
    uint64_t tx_transmission_delay = 1000ULL,
    bool rx_permitted = false,
    uint64_t last_changed_timestamp = 0,
    bool enable_live_logs = true) {
  LoRaSettingsBuilder builder_(_fbb);
  builder_.add_last_changed_timestamp(last_changed_timestamp);
  builder_.add_tx_transmission_delay(tx_transmission_delay);
  builder_.add_config(config);
  builder_.add_sat_name(sat_name);
  builder_.add_enable_live_logs(enable_live_logs);
  builder_.add_rx_permitted(rx_permitted);
  builder_.add_tx_permitted(tx_permitted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoRaSettings> CreateLoRaSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sat_name = nullptr,
    ::flatbuffers::Offset<groundstation::LoRaConfig> config = 0,
    bool tx_permitted = true,
    uint64_t tx_transmission_delay = 1000ULL,
    bool rx_permitted = false,
    uint64_t last_changed_timestamp = 0,
    bool enable_live_logs = true) {
  auto sat_name__ = sat_name ? _fbb.CreateString(sat_name) : 0;
  return groundstation::CreateLoRaSettings(
      _fbb,
      sat_name__,
      config,
      tx_permitted,
      tx_transmission_delay,
      rx_permitted,
      last_changed_timestamp,
      enable_live_logs);
}

inline const groundstation::LoRaSettings *GetLoRaSettings(const void *buf) {
  return ::flatbuffers::GetRoot<groundstation::LoRaSettings>(buf);
}

inline const groundstation::LoRaSettings *GetSizePrefixedLoRaSettings(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<groundstation::LoRaSettings>(buf);
}

inline bool VerifyLoRaSettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<groundstation::LoRaSettings>(nullptr);
}

inline bool VerifySizePrefixedLoRaSettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<groundstation::LoRaSettings>(nullptr);
}

inline void FinishLoRaSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<groundstation::LoRaSettings> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLoRaSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<groundstation::LoRaSettings> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace groundstation

#endif  // FLATBUFFERS_GENERATED_LORASETTINGS_GROUNDSTATION_H_
